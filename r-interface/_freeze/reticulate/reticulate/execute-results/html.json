{
  "hash": "4092a74eee6aad07fbcefc465f58277e",
  "result": {
    "markdown": "---\ntitle: \"Using up-to-date Gudhi library in R\"\nauthor: \"Aymeric Stamm\"\ndate: 2022-06-13\n---\n\n\n\n\n## Initial setup\n\nLet us start by loading the\n[**reticulate**](https://rstudio.github.io/reticulate/) package into the\nenvironment, along with the [**tidyverse**](https://www.tidyverse.org),\nwhich is a suite of useful packages for data science:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reticulate)\n# install.packages(\"tidyverse\")\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n\nLet us inform the R session that we want to use the virtual environment\n`r-reticulate` where we installed all the required Python packages (see\n`README` at the root of the project). This is done with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_condaenv(\"r-reticulate\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The request to `use_python(\"/Users/stamm-a/Library/r-miniconda/envs/\nr-reticulate/bin/python\")` will be ignored because the environment variable\nRETICULATE_PYTHON is set to \"/Users/stamm-a/Library/r-miniconda/envs/r-\nreticulate/bin/python3.9\"\n```\n:::\n:::\n\n\nIf you want to check your Python configuration, you can do:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npy_config()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npython:         /Users/stamm-a/Library/r-miniconda/envs/r-reticulate/bin/python3.9\nlibpython:      /Users/stamm-a/Library/r-miniconda/envs/r-reticulate/lib/libpython3.9.dylib\npythonhome:     /Users/stamm-a/Library/r-miniconda/envs/r-reticulate:/Users/stamm-a/Library/r-miniconda/envs/r-reticulate\nversion:        3.9.6 | packaged by conda-forge | (default, Jul 11 2021, 03:36:15)  [Clang 11.1.0 ]\nnumpy:          /Users/stamm-a/Library/r-miniconda/envs/r-reticulate/lib/python3.9/site-packages/numpy\nnumpy_version:  1.22.4\n\nNOTE: Python version was forced by RETICULATE_PYTHON\n```\n:::\n:::\n\n\nYou can now create chunks of Python code that will be correctly\ninterpreted when knitting your document into an HTML file. Let us make a\nfirst Python chunk of code to import **numpy** and **gudhi**:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport gudhi as gd\nimport gudhi.representations\n```\n:::\n\n\n## Full example\n\n### Data model\n\nFirst, we will generate persistence diagrams with orbits of dynamical\nsystems. This data set is very common in TDA. We use the following\nsystem, which depends on a parameter $r > 0$:\n\n\n$$\n\\begin{cases}\nx_{n+1} = x_n + r y_n (1 - y_n) \\mbox{ mod } 1 \\\\\ny_{n+1} = y_n + r x_{n+1} (1 - x_{n+1}) \\mbox{ mod } 1\n\\end{cases}\n$$\n\n\nLet's first see what the point cloud looks like for a given choice of\n$r$.\n\nWe first define a **Python** function to compute a single point cloud\naccording to the above orbit model and then use the\n[**Gudhi**](https://gudhi.inria.fr) library to compute the persistence\ndiagrams from its alpha complex and turn it into its silhouette\nrepresentation. This can be achieved by a function that looks like:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef orbit_silhouette(num_pts = 1000, resolution = 1000, r = 2):\n  X = np.empty([num_pts, 2])\n  x, y = np.random.uniform(), np.random.uniform()\n  for i in range(num_pts):\n    X[i, :] = [x, y]\n    x = (X[i, 0] + r * X[i, 1] * (1 - X[i, 1])) % 1.\n    y = (X[i, 1] + r * x * (1 - x)) % 1.\n  acX = gd.AlphaComplex(points = X).create_simplex_tree()\n  dgmX = acX.persistence()\n  SH = gd.representations.Silhouette(\n    resolution = resolution, \n    weight = lambda x: np.power(x[1] - x[0], 1)\n  )\n  sh = SH.fit_transform([acX.persistence_intervals_in_dimension(1)])\n  return([np.linspace(SH.sample_range[0], SH.sample_range[1], resolution), sh[0]])\n```\n:::\n\n\nThis function returns a Python list of size 2. The first element is the\nabscissa grid and the second element is the silhouette value on the\ngrid.\n\nPython lists are automatically converted into atomic vectors in R.\nAutomatic conversions of data types between R and Python languages are\nimplemented in [**reticulate**](https://rstudio.github.io/reticulate/):\nsee <https://rstudio.github.io/reticulate/#type-conversions>.\n\n### Sample generation\n\nNow we can go back in **R** to use this **Python** function and generate\ntwo samples of silhouette profiles. To access any Python object\n`my_py_object` created in a previous chunk from an R chunk, use\n`py$my_py_object`. Following this logic, the Python function\n`orbit_silhouette()` created in the above Python chunk is accessible\nfrom any subsequent R chunk as `py$orbit_silhouette()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn1 <- 10\nn2 <- 10\nx1 <- replicate(n1, py$orbit_silhouette(r = 1.9), simplify = FALSE)\nx2 <- replicate(n2, py$orbit_silhouette(r = 2.1), simplify = FALSE)\n\nt1 <- x1 |> map(1) |> map(~ c(0, .x))\nx1 <- x1 |> map(2) |> map(~ c(0, .x))\nt2 <- x2 |> map(1) |> map(~ c(0, .x))\nx2 <- x2 |> map(2) |> map(~ c(0, .x))\n\ndf <- bind_rows(\n  tibble(id = 1:n1, x = t1, y = x1) |> \n    unnest(cols = c(x, y)) |> \n    mutate(r = \"1.9\"), \n  tibble(id = 1:n2, x = t2, y = x2) |> \n    unnest(cols = c(x, y)) |> \n    mutate(r = \"2.1\")\n) |> \n  mutate(\n    id = as_factor(id), \n    r = as_factor(r)\n  )\ndf |> \n  ggplot(aes(x, y, color = r, group = interaction(id, r))) +\n  geom_line() + \n  scale_color_viridis_d()\n```\n\n::: {.cell-output-display}\n![](reticulate_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "reticulate_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}